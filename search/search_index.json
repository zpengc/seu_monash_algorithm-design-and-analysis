{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\u4e1c\u5357\u5927\u5b66\u7b97\u6cd5\u8bbe\u8ba1\u4e0e\u5206\u6790\u8bfe\u7a0bOJ http://47.99.179.148/ C++\u4e2d\u5404\u79cd\u8f93\u5165\u51fd\u6570\u7684\u7f13\u51b2\u533a\u95ee\u9898 string - Using getline() in C++ - Stack Overflow convert int to double to avoid potential integer overflow Trying to return as double, getting integer in C++ - Stack Overflow c-prefixed\u5934\u6587\u4ef6\u548c.h extension\u6587\u4ef6\u533a\u522b c++ - cmath vs math.h (And similar c-prefixed vs .h extension headers) - Stack Overflow","title":"Home"},{"location":"#oj-http4799179148","text":"C++\u4e2d\u5404\u79cd\u8f93\u5165\u51fd\u6570\u7684\u7f13\u51b2\u533a\u95ee\u9898 string - Using getline() in C++ - Stack Overflow convert int to double to avoid potential integer overflow Trying to return as double, getting integer in C++ - Stack Overflow c-prefixed\u5934\u6587\u4ef6\u548c.h extension\u6587\u4ef6\u533a\u522b c++ - cmath vs math.h (And similar c-prefixed vs .h extension headers) - Stack Overflow","title":"\u4e1c\u5357\u5927\u5b66\u7b97\u6cd5\u8bbe\u8ba1\u4e0e\u5206\u6790\u8bfe\u7a0bOJ http://47.99.179.148/"},{"location":"1000%20A%2BB%3DC/","text":"#include <iostream> using namespace std; int main() { int n, a, b; cin >> n; for(int i=0; i<n; i++) { cin >> a >> b; cout << a + b << endl; } return 0; }","title":"1000 A+B=C"},{"location":"1001%20%E7%BB%9F%E8%AE%A1%E6%95%B0%E5%AD%97%E4%B8%AA%E6%95%B0/","text":"#include <iostream> #include <string> using namespace std; int main() { int n; cin>>n; string str; getline(cin, str); for(int i=0;i<n;i++) { getline(cin, str); int num=0; for(int j=0;j<str.size();j++) { if(str[j]>='0' && str[j]<='9') { num++; } } cout<<num<<endl; } return 0; }","title":"1001 \u7edf\u8ba1\u6570\u5b57\u4e2a\u6570"},{"location":"1002%20%E6%89%BE%E7%AC%AC2%E5%B0%8F%E6%95%B0/","text":"#include <iostream> #include<limits.h> using namespace std; int f(int a[], int size) { int first, second; if (size < 2) { return 0; } first = second = INT_MAX; for(int i=0;i<size;i++) { if(a[i]<first) { second = first; first = a[i]; } else if(a[i]<second && a[i]!=first) { second = a[i]; } } return second; } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; int a[size]; for(int j=0; j<size; j++) cin >> a[j]; cout<<f(a, size)<<endl; } return 0; }","title":"1002 \u627e\u7b2c2\u5c0f\u6570"},{"location":"1003%20%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/","text":"#include <iostream> using namespace std; void bubble_sort_one_iter(int a[], int size) { for(int i=0;i<size-1;i++) { if(a[i]>a[i+1]) { swap(a[i], a[i+1]); } } for(int i=0;i<size;i++) { cout<<a[i]<<\" \"; } cout<<endl; } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; int a[size]; for(int i=0;i<size;i++) { cin>>a[i]; } bubble_sort_one_iter(a, size); } return 0; }","title":"1003 \u5192\u6ce1\u6392\u5e8f"},{"location":"1004%20%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/","text":"#include <iostream> using namespace std; int temp[1000]; int res[1000]; void merge(int a[], int low, int middle, int high){ int i=low,k=low,j=middle+1; while(i <= middle && j <= high){ if(a[i]<=a[j]) temp[k++]=a[i++]; else temp[k++]=a[j++]; } while(i<=middle) temp[k++]=a[i++]; while(j<=high) temp[k++]=a[j++]; for(k=low;k<=high;k++) a[k] = temp[k]; return; } void merge_sort(int a[], int low, int high, int level) { if (low >= high) { return; } int middle = (low+high)/2; merge_sort(a, low, middle, level+1); merge_sort(a, middle+1, high, level+1); merge(a, low, middle, high); if(level==3) { for(int i=low;i<=high;i++) { res[i] = a[i]; } } } void print(int a[], int size) { for(int i=0;i<size;i++) { cout<<a[i]<<\" \"; } cout<<endl; } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; int a[size]; for(int i=0;i<size;i++) { cin>>a[i]; } merge_sort(a, 0, size-1, 1); print(res, size); } return 0; }","title":"1004 \u5f52\u5e76\u6392\u5e8f"},{"location":"1005%20%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/","text":"#include <iostream> #include<limits.h> using namespace std; int f(int a[], int size) { int first, second; if (size < 2) { return 0; } first = second = INT_MAX; for(int i=0;i<size;i++) { if(a[i]<first) { second = first; first = a[i]; } else if(a[i]<second && a[i]!=first) { second = a[i]; } } return second; } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; int a[size]; for(int j=0; j<size; j++) cin >> a[j]; cout<<f(a, size)<<endl; } return 0; }","title":"1005 \u5feb\u901f\u6392\u5e8f"},{"location":"1006%20%E5%A0%86%E6%8E%92%E5%BA%8F/","text":"#include <iostream> using namespace std; void heapify(int a[], int size, int idx) { int smallest = idx; int left = idx*2+1; int right = idx*2+2; // \u4f18\u5148\u5411\u5de6\u5b50\u6811\u8c03\u6574 if(left<size && a[left]<a[smallest]) { smallest = left; } if(right<size && a[right]<a[smallest]) { smallest = right; } if(smallest!=idx) { swap(a[idx], a[smallest]); // \u7ee7\u7eed\u8c03\u6574\u4ee5\u5b69\u5b50\u4e3a\u6839\u8282\u70b9\u7684\u5b50\u6811 heapify(a, size, smallest); } } void heap_sort(int a[], int size) { // \u5efa\u5806 for(int i=size/2-1;i>=0;i--) { heapify(a, size, i); } } void print(int a[], int size) { for(int i=0;i<size;i++) { cout<<a[i]<<\" \"; } cout<<endl; } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; int a[size]; for(int i=0;i<size;i++) { cin>>a[i]; } heap_sort(a, size); print(a, size); } return 0; }","title":"1006 \u5806\u6392\u5e8f"},{"location":"1007%20%E6%9C%80%E5%A4%A7%E4%B9%98%E7%A7%AF/","text":"#include<iostream> #include<cstring> #include<string> using namespace std; //\u8fd4\u56dev[start]~v[end]\u8fd9\u4e9b\u6570\u5b57\u6240\u8868\u793a\u7684\u6570\u503c long nums(int v[],int start,int end){ long num=v[start]; for(int k=start+1;k<=end;k++){ num = num*10+v[k]; } return num; } long MaxMult(int v[], int bits,int k){ // \u539f\u6570\u5b570~bits-1\u4f4d\u4e2d\u52a0\u5165k\u4e2a\u4e58\u53f7\u6240\u5f97\u8868\u8fbe\u5f0f\u7684\u6700\u5927\u503c long dp[bits][k+1]; memset(dp,0,sizeof(dp)); for(int i=0; i<bits; i++) dp[i][0] = nums(v,0,i); //\u4e0d\u5212\u5206\u5c31\u662f\u524di\u4e2a\u4e00\u8d77\u6784\u6210\u4e00\u4e2a\u6570 //\u5728v[0]~v[i]\u4e4b\u95f4\u63d2\u5165j\u4e2a\u4e58\u53f7 for(int i=0; i<bits; i++) { //\u663e\u7136j\u7684\u4e2a\u6570\u4e0d\u80fd\u8d85\u8fc7i for(int j=1; j<=k&&j<i+1; j++) //\u63d2\u5165\u4e58\u53f7\u7684\u4f4d\u7f6e\u4e3ak for(int k=0;k<i;k++) dp[i][j] = max(dp[i][j],dp[k][j-1]*nums(v,k+1,i)); } return dp[bits-1][k]; } int main() { int n; cin >> n; for(int i=0; i<n; i++){ int bits; int k; cin>>bits>>k; string s; cin >> s; int v[bits]; for(int j=0;j<bits;j++) v[j] = s[j]-'0'; cout << MaxMult(v,bits,k) << endl; } return 0; }","title":"1007 \u6700\u5927\u4e58\u79ef"},{"location":"1008%20%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B92/","text":"#include<iostream> using namespace std; // Longest Decreasing Subsequence problem int LDS(int a[], int num) { int lds[num]; int max = 0; for (int i = 0; i < num; i++) { lds[i] = 1; } for (int i = 1; i < num; i++) { for (int j = 0; j < i; j++) { if (a[i] < a[j] && lds[i] < lds[j] + 1) { lds[i] = lds[j] + 1; } } } for (int i = 0; i < num; i++) { if (max < lds[i]) { max = lds[i]; } } return max; } int greedy(int a[], int num) { // height[i]\u8868\u793a\u7b2ci\u4e2a\u7cfb\u7edf\u80fd\u591f\u53d1\u5c04\u7684\u6700\u5927\u9ad8\u5ea6 int height[num]; // count\u7528\u6765\u8ba1\u6570 int count=0,min_idx=0; height[0] = a[0]; for(int i=1;i<num;i++) { if(a[i]>height[count]){ height[++count]=a[i]; } else{ min_idx=count; for(int j=count;j>=0;j--) { //\u6240\u6709\u7cfb\u7edf\u4e2d\u53d1\u5c04\u9ad8\u5ea6\u6700\u77ee\u7684\u90a3\u5957\u6765\u62e6\u622a if(height[j]<height[min_idx] && height[j]>=a[i]) { min_idx=j; } } height[min_idx]=a[i]; } } return count+1; } int main() { int n; cin >> n; for(int i=0; i<n; i++){ int num; cin>>num; int a[num]; for(int j=0;j<num;j++) { cin>>a[j]; } cout<<LDS(a, num)<<\" \"<<greedy(a, num)<<endl; } return 0; }","title":"1008 \u62e6\u622a\u5bfc\u5f392"},{"location":"1009%20%E6%8B%A6%E6%88%AA%E5%AF%BC%E5%BC%B91/","text":"#include<iostream> using namespace std; // Longest Decreasing Subsequence problem int LDS(int a[], int num) { int lds[num]; int max = 0; for (int i = 0; i < num; i++) { lds[i] = 1; } for (int i = 1; i < num; i++) { for (int j = 0; j < i; j++) { if (a[i] < a[j] && lds[i] < lds[j] + 1) { lds[i] = lds[j] + 1; } } } for (int i = 0; i < num; i++) { if (max < lds[i]) { max = lds[i]; } } return max; } int main() { int n; cin >> n; for(int i=0; i<n; i++){ int num; cin>>num; int a[num]; for(int j=0;j<num;j++) { cin>>a[j]; } cout<<LDS(a, num)<<endl; } return 0; }","title":"1009 \u62e6\u622a\u5bfc\u5f391"},{"location":"1010%20%E4%BA%8C%E5%88%86%E6%90%9C%E7%B4%A0/","text":"#include<iostream> using namespace std; void binary_search(int a[], int low, int high, int target) { int temp = a[(low+high)/2]; while(low<=high) { int mid = (low+high)/2; if(a[mid]==target) { cout<<\"success, father is \"<<temp<<endl; return; } else if(a[mid]>target) { high = mid-1; temp = a[mid]; } else { low = mid+1; temp = a[mid]; } } cout<<\"not found, father is \"<<temp<<endl; } int main() { int n; cin >> n; for(int i=0; i<n; i++){ int size; cin>>size; int target; cin>>target; int a[size]; for(int j=0;j<size;j++) { cin>>a[j]; } binary_search(a, 0, size-1, target); } return 0; }","title":"1010 \u4e8c\u5206\u641c\u7d20"},{"location":"1011%20%E6%9C%80%E8%BF%91%E7%82%B9%E5%AF%B9/","text":"#include<iostream> #include<cfloat> #include<math.h> #include<iomanip> using namespace std; struct Point { int x; int y; }; // http://www.cplusplus.com/reference/cstdlib/qsort/ qsort\u51fd\u6570\u9700\u8981compar\u51fd\u6570\u539f\u578b int compareX(const void* a, const void* b) { Point *p1 = (Point *)a, *p2 = (Point *)b; return (p1->x != p2->x) ? (p1->x - p2->x) : (p1->y - p2->y); } int compareY(const void* a, const void* b) { Point *p1 = (Point *)a, *p2 = (Point *)b; return (p1->y != p2->y) ? (p1->y - p2->y) : (p1->x - p2->x); } float dist(Point p1, Point p2) { // \u4e58\u4ee51.0\u9632\u6b62int\u7c7b\u578b\u6ea2\u51fa float x = sqrt( 1.0*(p1.x - p2.x)*1.0*(p1.x - p2.x) + 1.0*(p1.y - p2.y)*1.0*(p1.y - p2.y)); return x; } float bruteForce(Point P[], int n) { float min = FLT_MAX; for (int i = 0; i < n; ++i) for (int j = i+1; j < n; ++j) if (dist(P[i], P[j]) < min) min = dist(P[i], P[j]); return min; } float min(float x, float y) { return (x < y)? x : y; } float stripClosest(Point strip[], int size, float d) { float min = d; for (int i = 0; i < size; ++i) for (int j = i+1; j < size && (strip[j].y - strip[i].y) < min; ++j) if (dist(strip[i],strip[j]) < min) min = dist(strip[i], strip[j]); return min; } float closestUtil(Point Px[], Point Py[], int n) { if (n <= 3) return bruteForce(Px, n); int mid = n/2; Point midPoint = Px[mid]; Point Pyl[mid]; Point Pyr[n-mid]; int li = 0, ri = 0; for (int i = 0; i < n; i++) { if ((Py[i].x < midPoint.x || (Py[i].x == midPoint.x && Py[i].y < midPoint.y)) && li<mid) Pyl[li++] = Py[i]; else Pyr[ri++] = Py[i]; } float dl = closestUtil(Px, Pyl, mid); float dr = closestUtil(Px + mid, Pyr, n-mid); float d = min(dl, dr); Point strip[n]; int j = 0; for (int i = 0; i < n; i++) if (abs(Py[i].x - midPoint.x) < d) strip[j] = Py[i], j++; return stripClosest(strip, j, d); } float closest(Point P[], int n) { Point Px[n]; Point Py[n]; for (int i = 0; i < n; i++) { Px[i] = P[i]; Py[i] = P[i]; } qsort(Px, n, sizeof(Point), compareX); qsort(Py, n, sizeof(Point), compareY); return closestUtil(Px, Py, n); } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; Point P[size]; for(int i=0;i<size;i++) { Point p; cin>>p.x; cin>>p.y; P[i] = p; } cout<<fixed<<setprecision(2)<<closest(P, size) << endl; } return 0; }","title":"1011 \u6700\u8fd1\u70b9\u5bf9"},{"location":"1012%20%E5%AF%BB%E6%89%BE%E5%87%B8%E5%8C%85/","text":"#include<iostream> #include<vector> #include <stack> using namespace std; struct Point { int x, y; }; Point p0; // A utility function to find next to top in a stack Point nextToTop(stack<Point> &S) { Point p = S.top(); S.pop(); Point res = S.top(); S.push(p); return res; } // A utility function to swap two points void swap(Point &p1, Point &p2) { Point temp = p1; p1 = p2; p2 = temp; } // A utility function to return square of distance // between p1 and p2 int distSq(Point p1, Point p2) { return (p1.x - p2.x)*(p1.x - p2.x) + (p1.y - p2.y)*(p1.y - p2.y); } // To find orientation of ordered triplet (p, q, r). // The function returns following values // 0 --> p, q and r are collinear // 1 --> Clockwise // 2 --> Counterclockwise int orientation(Point p, Point q, Point r) { int val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y); if (val == 0) return 0; // collinear return (val > 0)? 1: 2; // clock or counterclock wise } // A function used by library function qsort() to sort an array of // points with respect to the first point int compare(const void *vp1, const void *vp2) { Point *p1 = (Point *)vp1; Point *p2 = (Point *)vp2; // Find orientation int o = orientation(p0, *p1, *p2); if (o == 0) return (distSq(p0, *p2) >= distSq(p0, *p1))? -1 : 1; return (o == 2)? -1: 1; } // Prints convex hull of a set of n points. void convexHull(Point points[], int n ,int id) { // Find the bottommost point int ymin = points[0].y, min = 0; for (int i = 1; i < n; i++) { int y = points[i].y; // Pick the bottom-most or chose the left // most point in case of tie if ((y < ymin) || (ymin == y && points[i].x < points[min].x)) ymin = points[i].y, min = i; } // Place the bottom-most point at first position swap(points[0], points[min]); // Sort n-1 points with respect to the first point. // A point p1 comes before p2 in sorted output if p2 // has larger polar angle (in counterclockwise // direction) than p1 p0 = points[0]; qsort(&points[1], n-1, sizeof(Point), compare); // If two or more points make same angle with p0, // Remove all but the one that is farthest from p0 // Remember that, in above sorting, our criteria was // to keep the farthest point at the end when more than // one points have same angle. int m = 1; // Initialize size of modified array for (int i=1; i<n; i++) { // Keep removing i while angle of i and i+1 is same // with respect to p0 while (i < n-1 && orientation(p0, points[i], points[i+1]) == 0) i++; points[m] = points[i]; m++; // Update size of modified array } // If modified array of points has less than 3 points, // convex hull is not possible if (m < 3) return; // Create an empty stack and push first three points // to it. stack<Point> S; S.push(points[0]); S.push(points[1]); S.push(points[2]); // Process remaining n-3 points for (int i = 3; i < m; i++) { // Keep removing top while the angle formed by // points next-to-top, top, and points[i] makes // a non-left turn while (S.size()>1 && orientation(nextToTop(S), S.top(), points[i]) != 2) S.pop(); S.push(points[i]); } // Now stack has the output points, print contents of stack cout<<\"case \"<<id+1<<\":\"<<endl; stack<Point> ss; while (!S.empty()) { Point p = S.top(); ss.push(p); S.pop(); } while (!ss.empty()) { Point p = ss.top(); cout << p.x << \" \" << p.y << endl; ss.pop(); } } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; Point p[size]; for(int j=0;j<size;j++) { cin>>p[j].x; cin>>p[j].y; } convexHull(p, size, i); } return 0; }","title":"1012 \u5bfb\u627e\u51f8\u5305"},{"location":"1013%20%E9%80%86%E5%BA%8F%E5%AF%B9/","text":"#include<iostream> using namespace std; int merge(int arr[], int temp[], int left, int mid, int right) { int i, j, k; int inv_count = 0; i = left; /* i is index for left subarray*/ j = mid; /* j is index for right subarray*/ k = left; /* k is index for resultant merged subarray*/ while ((i <= mid - 1) && (j <= right)) { if (arr[i] <= arr[j]) { temp[k++] = arr[i++]; } else { temp[k++] = arr[j++]; inv_count = inv_count + (mid - i); } } while (i <= mid - 1) temp[k++] = arr[i++]; while (j <= right) temp[k++] = arr[j++]; for (i = left; i <= right; i++) arr[i] = temp[i]; return inv_count; } int _mergeSort(int arr[], int temp[], int left, int right) { int inv_count = 0; if (right > left) { int mid = (right + left) / 2; inv_count += _mergeSort(arr, temp, left, mid); inv_count += _mergeSort(arr, temp, mid + 1, right); inv_count += merge(arr, temp, left, mid + 1, right); } return inv_count; } int mergeSort(int arr[], int array_size) { int temp[array_size]; return _mergeSort(arr, temp, 0, array_size - 1); } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; int arr[size]; for(int j=0;j<size;j++) { cin>>arr[j]; } cout<<mergeSort(arr, size)<<endl; } return 0; }","title":"1013 \u9006\u5e8f\u5bf9"},{"location":"1014%20%E6%9C%80%E5%A4%A7%E5%AD%90%E6%95%B0%E7%BB%84%E5%92%8C/","text":"#include<iostream> #include<climits> using namespace std; int func(int a[], int size) { int res = INT_MIN; int max_end_here = 0; for(int i=0;i<size;i++) { max_end_here += a[i]; if(max_end_here > res) { res = max_end_here; } if(max_end_here < 0) { max_end_here = 0; } } return res; } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; int arr[size]; for(int j=0;j<size;j++) { cin>>arr[j]; } cout<<func(arr, size)<<endl; } return 0; }","title":"1014 \u6700\u5927\u5b50\u6570\u7ec4\u548c"},{"location":"1015%20%E5%A4%A9%E6%9C%BA%E8%BD%AE%E5%BB%93/","text":"#include<iostream> #include<climits> #include<vector> #include<set> #include<algorithm> using namespace std; vector<pair<int, int>> getSkyline(vector<vector<int>>& buildings) { // use walls to record buildings; left wall is an insertion event, and right wall is a deletion event vector<pair<int, int>> walls, ans; // first: x, second: height for (auto b : buildings) { // push in left / right walls // let left wall has negative height to ensure left wall goes to multiset first if with same 'x' as right wall walls.push_back(make_pair(b[0], -b[2])); walls.push_back(make_pair(b[1], b[2])); } sort(walls.begin(), walls.end()); // sort walls multiset<int> leftWallHeights = {0}; // keep left wall heights sorted; dummy '0' for convenience int top = 0; // current max height among leftWallHeights for (auto w : walls) { if (w.second < 0) { // it's a left wall, insert the height leftWallHeights.insert(-w.second); } else { // it's a right wall, delete the height leftWallHeights.erase(leftWallHeights.find(w.second)); } if (*leftWallHeights.rbegin() != top) { // mark a skyline point if top changes ans.push_back(make_pair(w.first, top = *leftWallHeights.rbegin())); } } return ans; } void func(vector<vector<int>> buildings) { vector<pair<int, int>> ans = getSkyline(buildings); for (auto it : ans) { cout<<it.first<<\" \"<<it.second<<endl; } } int main() { const int tuple_size = 3; int n; cin>>n; vector<vector<int>> buildings; for(int i=0;i<n;i++) { vector<int> building(3); for(int j=0;j<tuple_size;j++) { cin>>building[j]; } buildings.push_back(building); } func(buildings); return 0; }","title":"1015 \u5929\u673a\u8f6e\u5ed3"},{"location":"1016%20%E4%B8%A4%E5%85%83%E7%B4%A0%E5%92%8C/","text":"#include<iostream> #include<unordered_set> using namespace std; bool func(int arr[], int size, int target) { unordered_set<int> s; for(int i=0;i<size;i++) { int remain = target - arr[i]; if(s.find(remain)!=s.end()) { return true; } else { s.insert(arr[i]); } } return false; } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size, target; cin>>size; cin>>target; int arr[size]; for(int j=0;j<size;j++) { cin>>arr[j]; } if(func(arr, size, target)) { cout<<\"yes\"<<endl; } else { cout<<\"no\"<<endl; } } return 0; }","title":"1016 \u4e24\u5143\u7d20\u548c"},{"location":"1017%20%E7%94%B5%E8%B7%AF%E5%B8%83%E7%BA%BF/","text":"#include<iostream> using namespace std; int merge(int array[], int const left, int const mid, int const right) { int s1 = mid - left + 1; int s2 = right - mid; int *leftArray = new int[s1], *rightArray = new int[s2]; for (int i = 0; i < s1; i++) leftArray[i] = array[left + i]; for (int j = 0; j < s2; j++) rightArray[j] = array[mid + 1 + j]; int indexOfSubArrayOne = 0, indexOfSubArrayTwo = 0; int indexOfMergedArray = left; int sum=0; while (indexOfSubArrayOne < s1 && indexOfSubArrayTwo < s2) { if (leftArray[indexOfSubArrayOne] <= rightArray[indexOfSubArrayTwo]) { array[indexOfMergedArray] = leftArray[indexOfSubArrayOne]; indexOfSubArrayOne++; sum+=indexOfSubArrayTwo; } else { array[indexOfMergedArray] = rightArray[indexOfSubArrayTwo]; indexOfSubArrayTwo++; } indexOfMergedArray++; } while (indexOfSubArrayOne < s1) { array[indexOfMergedArray] = leftArray[indexOfSubArrayOne]; indexOfSubArrayOne++; indexOfMergedArray++; sum+=indexOfSubArrayTwo; } while (indexOfSubArrayTwo < s2) { array[indexOfMergedArray] = rightArray[indexOfSubArrayTwo]; indexOfSubArrayTwo++; indexOfMergedArray++; } return sum; } int mergeSort(int array[], int begin, int end) { if (begin >= end) return 0; int sum=0; auto mid = (begin + end) / 2; sum+=mergeSort(array, begin, mid); sum+=mergeSort(array, mid + 1, end); sum+=merge(array, begin, mid, end); return sum; } int main() { int n; cin>>n; for(int i=0;i<n;i++) { int size; cin>>size; int arr[size]; for(int j=0;j<size;j++) { cin>>arr[j]; } cout<<mergeSort(arr, 0, size-1)<<endl; } return 0; }","title":"1017 \u7535\u8def\u5e03\u7ebf"},{"location":"1018%2001%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%982/","text":"#include<iostream> #include<vector> using namespace std; int func(int weight[], int profit[], int capacity, int n_gem) { vector<vector<int>> dp(n_gem+1, vector<int>(capacity+1, -1)); for(int i=0;i<=n_gem;i++) { dp[i][0] = 0; } for (int i=1;i<=n_gem;i++) { for (int j=capacity;j>=1;j--) { // weight, profit\u6570\u7ec4\u4e0b\u6807\u4ece0\u5f00\u59cb\uff0c\u6240\u4ee5i-1 int curr_weight = weight[i - 1]; int curr_profit = profit[i - 1]; if (j >= curr_weight && dp[i - 1][j - curr_weight] != -1) { dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - curr_weight] + curr_profit); } else { dp[i][j] = dp[i - 1][j]; } } } if(dp[n_gem][capacity] == -1) { return 0; } return dp[n_gem][capacity]; } int main() { // \u6d4b\u8bd5\u6b21\u6570 int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { // \u5b9d\u77f3\u4e2a\u6570 int n_gem; cin>>n_gem; // \u80cc\u5305\u5bb9\u91cf int bag_capacity; cin>>bag_capacity; int weight[n_gem]; int profit[n_gem]; for(int i=0;i<n_gem;i++) { // \u5b9d\u77f3\u5927\u5c0f int weight_gem; cin>>weight_gem; // \u5b9d\u77f3\u4ef7\u503c int profit_gem; cin>>profit_gem; weight[i] = weight_gem; profit[i] = profit_gem; } cout<<func(weight, profit, bag_capacity, n_gem)<<endl; } return 0; }","title":"1018 01\u80cc\u5305\u95ee\u98982"},{"location":"1019%2001%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%981/","text":"#include<iostream> #include<vector> using namespace std; int func(int weight[], int profit[], int capacity, int n_gem) { vector<vector<int>> dp(n_gem + 1, vector<int>(capacity + 1)); for(int i=0;i<=n_gem;i++) { dp[i][0] = 0; } for(int i=0;i<=capacity;i++) { dp[0][i] = 0; } for(int i = 1; i <= n_gem; i++) { for(int j = 1; j <= capacity; j++) { // \u5bb9\u91cf\u5141\u8bb8\uff0c\u53ef\u4ee5\u88c5\u5165\u7269\u54c1 if(j >= weight[i-1]) { // \u5206\u4e3a\u4e24\u79cd\u60c5\u51b5\uff0c\u88c5\u5165\u7269\u54c1\u548c\u4e0d\u88c5\u5165\u7269\u54c1 dp[i][j] = max(profit[i - 1] + dp[i - 1][j - weight[i - 1]], dp[i - 1][j]); } // \u5bb9\u91cf\u4e0d\u8db3\uff0c\u4e0d\u88c5\u5165\u8be5\u7269\u54c1 else { dp[i][j] = dp[i-1][j]; } } } return dp[n_gem][capacity]; } int main() { // \u6d4b\u8bd5\u6b21\u6570 int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { // \u5b9d\u77f3\u4e2a\u6570 int n_gem; cin>>n_gem; // \u80cc\u5305\u5bb9\u91cf int bag_capacity; cin>>bag_capacity; int weight[n_gem]; int profit[n_gem]; for(int i=0;i<n_gem;i++) { // \u5b9d\u77f3\u5927\u5c0f int weight_gem; cin>>weight_gem; // \u5b9d\u77f3\u4ef7\u503c int profit_gem; cin>>profit_gem; weight[i] = weight_gem; profit[i] = profit_gem; } cout<<func(weight, profit, bag_capacity, n_gem)<<endl; } return 0; }","title":"1019 01\u80cc\u5305\u95ee\u98981"},{"location":"1020%20%E7%9F%A9%E9%98%B5%E8%BF%9E%E4%B9%98/","text":"#include<iostream> #include<climits> using namespace std; // \u6570\u7ec4\u957f\u5ea6\u4e3an\uff0c\u77e9\u9635\u4e2a\u6570\u4e3an-1 int min_cost(int p[], int n) { // m[i,j]\u8868\u793a\u77e9\u9635matrix[i] matrix[i+1] ... matrix[j-1] matrix[j]\u7684\u6700\u5c0f\u4e58\u6cd5\u4ee3\u4ef7 int m[n][n]; int i, j, k, L, q; // \u4e00\u4e2a\u77e9\u9635\uff0c\u4e0d\u5b58\u5728\u6700\u5c0f\u4e58\u6cd5\u4ee3\u4ef7\uff0c\u4e3a0 // \u7d22\u5f15\u4ece1\u5230n-1\uff0c\u8868\u793a\u77e9\u96351-\u77e9\u9635n-1 for (i=1; i<n; i++) m[i][i] = 0; //L\u8868\u793a\u8fde\u4e58\u7684\u77e9\u9635\u4e2a\u6570\uff0c\u4ece2\u5230n-1 for (L=2; L<n; L++) { // n-gram\u7684\u601d\u60f3\uff0c\u4ee5L\u4e3a\u5355\u4f4d\u8fdb\u884c\u5206\u5272\uff0c\u6700\u5c11\u5206\u62101\u4e2a\uff0c\u6700\u591a\u5206\u6210n-L+1\u4e2a for (i=1; i<n-L+1; i++) { // j\u8868\u793a\u540c\u4e00\u4e2a\u8fde\u4e58\u957f\u5ea6\u5185\u7684\u6700\u540e\u4e00\u4e2a\u5143\u7d20\u7684\u4e0b\u6807 j = i+L-1; m[i][j] = INT_MAX; for (k=i; k<=j-1; k++) { // m[i][k]\u8fde\u4e58\u540e\u7684\u7ed3\u679c\u77e9\u9635\uff1ap[i-1]\u884c\uff0cp[k]\u5217 // m[k+1][j]\u8fde\u4e58\u540e\u7684\u7ed3\u679c\u77e9\u9635\uff1ap[k]\u884c\uff0cp[j]\u5217 // \u4e24\u4e2a\u7ed3\u679c\u77e9\u9635\u8fde\u4e58\u4ee3\u4ef7\uff1ap[i-1]*p[k]*p[j] q = m[i][k] + m[k+1][j] + p[i-1]*p[k]*p[j]; if (q < m[i][j]) { m[i][j] = q; } } } } return m[1][n-1]; } int main() { // \u6d4b\u8bd5\u6b21\u6570 int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { // \u77e9\u9635\u4e2a\u6570 int n_matrix; cin>>n_matrix; // \u5b58\u50a8\u6bcf\u4e2a\u77e9\u9635\u7684\u884c\u6570\u548c\u5217\u6570\uff0c\u524d\u4e00\u4e2a\u77e9\u9635\u7684\u5217\u6570\u548c\u540e\u4e00\u4e2a\u77e9\u9635\u7684\u884c\u6570\u91cd\u590d\uff0c\u53ea\u5b58\u50a81\u4e2a\uff0c\u56e0\u6b64\u5927\u5c0f\u4e3a2*n_matrix-(n_matrix-1) int chain[n_matrix+1]; for(int i=0;i<n_matrix;i++) { // \u884c\u548c\u5217 int row; cin>>row; int col; cin>>col; if(i==0) { chain[i] = row; chain[i+1] = col; } else { chain[i+1] = col; } } cout<<min_cost(chain, n_matrix+1)<<endl; } return 0; }","title":"1020 \u77e9\u9635\u8fde\u4e58"},{"location":"1021%20%E9%92%A2%E6%9D%A1%E5%88%87%E5%89%B2/","text":"#include<iostream> #include<climits> using namespace std; // \u65e0\u9650\u80cc\u5305\u95ee\u9898\uff0c\u94a2\u6750\u76f8\u5f53\u4e8e\u80cc\u5305\uff0c\u6bcf\u4e2a\u552e\u5356\u7684\u5c0f\u6bb5\u94a2\u6750\u76f8\u5f53\u4e8e\u7269\u54c1\uff0c\u5047\u8bbe\u6bcf\u79cd\u552e\u5356\u7684\u5c0f\u6bb5\u94a2\u6750\u662f\u6ca1\u6709\u6570\u91cf\u9650\u5236\u7684 // dp\u6570\u7ec4\u7533\u8bf7\u4e3a1\u7ef4\u6570\u7ec4\uff0c2\u7ef4\u6570\u7ec4\u663e\u793a\u5185\u5b58\u4e0d\u8db3\u9519\u8bef int cut_rod(int prices[], int sizes[], int capacity, int n) { // \u5c40\u90e8\u53d8\u91cf\u8d4b\u503c\u4e3a0\uff0c\u5426\u5219\u7cfb\u7edf\u8d4b\u968f\u673a\u503c int dp[capacity+1] = {0,}; // \u80cc\u5305\u5bb9\u91cf\u4e3a0 dp[0] = 0; // \u4ece\u5c0f\u5230\u5927\u904d\u5386\u6240\u6709\u80cc\u5305\u5bb9\u91cf for(int i=1;i<=capacity;i++) { // \u904d\u5386\u6240\u6709\u7269\u54c1 for(int j=0;j<n;j++) { // \u5bb9\u91cf\u5141\u8bb8\u7684\u60c5\u51b5\u4e0b if(sizes[j]<=i) { dp[i] = max(dp[i], dp[i-sizes[j]] + prices[j]); } } } return dp[capacity]; } int main() { // \u6d4b\u8bd5\u6b21\u6570 int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { // \u94a2\u6761\u957f\u5ea6 int capacity; cin>>capacity; // \u4ef7\u76ee\u8868\u4ef7\u683c\u79cd\u7c7b\u6570 int n_types; cin>>n_types; int prices[n_types]; int sizes[n_types]; for(int j=0;j<n_types;j++) { cin>>sizes[j]; cin>>prices[j]; } cout<<cut_rod(prices, sizes, capacity, n_types)<<endl; } return 0; }","title":"1021 \u94a2\u6761\u5207\u5272"},{"location":"1022%20%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%AD%90%E5%BA%8F%E5%88%97/","text":"#include<iostream> #include<string> using namespace std; //\u6700\u957f\u516c\u5171\u5e8f\u5217\u548c\u6700\u957f\u516c\u5171\u5b50\u4e32\u4e0d\u662f\u4e00\u4e2a\u95ee\u9898 // longest common sequence int lcs(string s, string t, int m, int n) { // dp[i][j]\u8868\u793a\u957f\u5ea6\u4e3ai\u7684\u5b57\u7b26\u4e32\u548c\u957f\u5ea6\u4e3aj\u7684\u5b57\u7b26\u4e32\u7684lcs int dp[m+1][n+1] = {0,}; for(int i=0;i<=m;i++) { for(int j=0;j<=n;j++) { // \u4efb\u4f55\u4e00\u4e2a\u5b57\u7b26\u4e32\u957f\u5ea6\u4e3a0\uff0clcs\u7ed3\u679c\u4e3a0 if(i==0 || j==0) { dp[i][j] = 0; } // \u4e24\u4e2a\u5b57\u7b26\u4e32\u6700\u540e\u4e00\u4e2a\u5b57\u7b26\u76f8\u540c else if(s[i-1] == t[j-1]) { // \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b1 dp[i][j] = dp[i-1][j-1] + 1; } else { // \u72b6\u6001\u8f6c\u79fb\u65b9\u7a0b2 dp[i][j] = max(dp[i-1][j], dp[i][j-1]); } } } return dp[m][n]; } int main() { // \u6d4b\u8bd5\u6b21\u6570 int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { string s1; string s2; cin>>s1; cin>>s2; cout<<lcs(s1, s2, s1.size(), s2.size())<<endl; } return 0; }","title":"1022 \u6700\u957f\u516c\u5171\u5b50\u5e8f\u5217"},{"location":"1025%20%E6%9C%80%E9%95%BF%E9%9D%9E%E9%99%8D%E5%AD%90%E5%BA%8F%E5%88%97/","text":"#include<iostream> #include<climits> using namespace std; int func(int arr[], int n) { int dp[n] = {1,}; for(int i=0;i<n;i++) { dp[i] = 1; } for (int i = 1; i < n; i++) { for (int j = 0; j < i; j++) if (arr[i] >= arr[j]) dp[i] = max(dp[i], dp[j] + 1); } int ans = INT_MIN; for(int i=0;i<n;i++) { if(dp[i] > ans) { ans = dp[i]; } } return ans; } int main() { // \u6d4b\u8bd5\u6b21\u6570 int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { int num; cin>>num; int arr[num]; for(int j=0;j<num;j++) { cin>>arr[j]; } cout<<func(arr, num)<<endl; } return 0; }","title":"1025 \u6700\u957f\u975e\u964d\u5b50\u5e8f\u5217"},{"location":"1026%20%E6%8F%92%E5%85%A5%E4%B9%98%E5%8F%B7/","text":"#include<iostream> using namespace std; long long func(int arr[],int n, int k) { // dp[i][j]\u8868\u793a\u5728\u7b2c1\u5230\u7b2ci\u4e2a\u6570\u91cc\u9762\u63d2\u5165j\u4e2a\u4e58\u53f7\u5f97\u5230\u7684\u6700\u5927\u503c long long dp[n+1][n+1]; long long sum[n+1]; sum[0]=0; // \u5b58\u50a8\u7d2f\u52a0\u548c for(int i=1; i<=n;i++) { sum[i] = sum[i-1] + arr[i]; } for(int i=1; i<=n;i++) { dp[i][0] = sum[i]; } for(int i=2;i<=n;++i) for(int j=1;j<i;++j) dp[i][j]=-1; // j\u8868\u793a\u4e58\u6cd5\u7b26\u53f7\u4e2a\u6570 for(int j=1;j<=k;++j) { // \u4e58\u53f7\u53ef\u4ee5\u653e\u5165\u7684\u8303\u56f4\uff0c[1,i] for(int i=j+1;i<=n;++i) { // \u4e58\u53f7\u653e\u5165k\u4f4d\u7f6e\uff0ck\u4e4b\u524d\u7684\u4f4d\u7f6e\u5df2\u7ecf\u88ab\u6d4b\u8bd5\u8fc7\u4e86 for(int k=j+1;k<=i;++k) { // dp[k-1][j-1]\u8868\u793a\u4e58\u6cd5\u63d2\u5165\u540e\u7684\u5de6\u90e8\u5206\uff0csum[i] = sum[k-1]\u8868\u793a\u53f3\u90e8\u5206 dp[i][j]=max(dp[i][j],dp[k-1][j-1]*(sum[i]-sum[k-1])); } } } return dp[n][k]; } int main() { int n_test; cin >> n_test; for(int i=0; i<n_test; i++){ int n; int k; cin>>n; cin>>k; int arr[n+1]; for(int j=1;j<=n;j++){ cin >> arr[j]; } cout<<func(arr,n,k)<<endl; } return 0; }","title":"1026 \u63d2\u5165\u4e58\u53f7"},{"location":"1027%20%E5%B8%A6%E6%9D%83%E6%B4%BB%E5%8A%A8%E9%80%89%E6%8B%A9/","text":"#include<iostream> #include<algorithm> using namespace std; struct activity { int start_time; int finish_time; int weight; }; bool compare(activity a1, activity a2) { return (a1.finish_time != a2.finish_time) ? (a1.finish_time < a2.finish_time) : (a1.start_time < a2.start_time); } int get_last_activity(activity arr[], int idx) { // arr\u4e3a\u6839\u636e\u7ed3\u675f\u65f6\u95f4\u6392\u5e8f\u540e\u7684\u6570\u7ec4 // \u4ece\u540e\u5f80\u524d\u627e for(int i=idx-1;i>=0;i--) { if(arr[i].finish_time <= arr[idx].start_time) { return i; } } return -1; } int choose(activity arr[], int n) { int dp[n+1]; dp[1] = arr[0].weight; for(int i=2;i<=n;i++) { int sum = arr[i-1].weight; int idx = get_last_activity(arr, i-1); if(idx!=-1) { sum += dp[idx+1]; } dp[i] = max(sum, dp[i-1]); } return dp[n]; } int main() { // \u6d4b\u8bd5\u6b21\u6570 int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { // \u6d3b\u52a8\u4e2a\u6570 int n_activity; cin>>n_activity; activity arr[n_activity]; for(int j=0;j<n_activity;j++) { activity temp; cin>>temp.start_time; cin>>temp.finish_time; cin>>temp.weight; arr[j] = temp; } sort(arr, arr+n_activity, compare); cout<<choose(arr, n_activity)<<endl; } return 0; }","title":"1027 \u5e26\u6743\u6d3b\u52a8\u9009\u62e9"},{"location":"1039%20%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/","text":"#include<iostream> #include<vector> #include<queue> using namespace std; int main() { int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { int n_vertex; int n_edge; cin>>n_vertex; cin>>n_edge; int in_degree[n_vertex+1] = {0,}; vector<vector<int>> adj(n_vertex+1, vector<int>(n_vertex+1, 0)); vector<int> ans; queue<int> zero_degree; for(int j=0;j<n_edge;j++) { //u->v int u; int v; cin>>u; cin>>v; adj[u].push_back(v); in_degree[v]++; } for(int k=1;k<=n_vertex;k++) { if(in_degree[k]==0) { zero_degree.push(k); } } int num = 0; while(!zero_degree.empty()) { int vertice = zero_degree.front(); zero_degree.pop(); ans.push_back(vertice); for(int i=0;i<adj[vertice].size();i++) { if(adj[vertice][i]!=0 &&--in_degree[adj[vertice][i]]==0) { zero_degree.push(adj[vertice][i]); } } num++; } if(num!=n_vertex) { cout<<\"0\"; } else { for(int i=0;i<ans.size();i++) { cout<<ans[i]<<\" \"; } } cout<<endl; } }","title":"1039 \u62d3\u6251\u6392\u5e8f"},{"location":"1040%20%E6%90%9C%E7%B4%A2%E4%BA%8C%E4%BD%8D%E7%9F%A9%E9%98%B5/","text":"#include<iostream> #include<vector> #include<iomanip> using namespace std; // \u601d\u60f3\u5c31\u662f\u548c\u77e9\u9635\u53f3\u4e0a\u89d2\u5143\u7d20\u6bd4\u8f83\uff0c\u4e0d\u65ad\u7f29\u5c0f\u8303\u56f4 bool search(vector<vector<int>> matrix, int row, int col, int target) { if(row==0 || col==0) { return false; } int i = 0; int j = col-1; while(i<row && j>=0) { if(target == matrix[i][j]) { return true; } else if(target < matrix[i][j]) { j--; } else { i++; } } return false; } int main() { int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { int row; int col; int target; cin>>row; cin>>col; cin>>target; vector<vector<int>> matrix(row, vector<int>(col)); for(int i=0;i<row;i++) { for(int j=0;j<col;j++) { cin>>matrix[i][j]; } } cout<<boolalpha<<search(matrix, row, col, target)<<endl; } }","title":"1040 \u641c\u7d22\u4e8c\u4f4d\u77e9\u9635"},{"location":"1041%20%E5%AF%BB%E6%89%BE%E4%B8%A4%E4%B8%AA%E6%AD%A3%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0/","text":"#include<iostream> #include<algorithm> #include<iomanip> using namespace std; // leetcode 4. // https://leetcode.com/problems/median-of-two-sorted-arrays/ float func(int arr1[], int arr2[], int len_1, int len_2) { int arr[len_1+len_2]; int p = 0; int q = 0; int idx = 0; while(p<len_1 && q<len_2) { if(arr1[p] <= arr2[q]) { arr[idx++] = arr1[p++]; } else { arr[idx++] = arr2[q++]; } } while(p<len_1) { arr[idx++] = arr1[p++]; } while(q<len_2) { arr[idx++] = arr2[q++]; } if( (len_1+len_2)%2!=0 ) { return arr[(len_1+len_2)/2]; } else { return ( arr[(len_1+len_2)/2] + arr[(len_1+len_2)/2-1] ) / 2.0; } } int main() { int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { int len_1; int len_2; cin>>len_1; cin>>len_2; int arr_1[len_1]; int arr_2[len_2]; for(int j=0;j<len_1;j++) { cin>>arr_1[j]; } for(int j=0;j<len_2;j++) { cin>>arr_2[j]; } // \u8f93\u5165\u7684\u6570\u636e\u5df2\u7ecf\u662f\u6709\u5e8f\u4e86\uff0c\u4e0d\u9700\u8981\u518d\u6392\u5e8f // sort(arr_1, arr_1+len_1); // sort(arr_2, arr_2+len_2); // \u9898\u76eebug\uff0c\u4e0d\u9700\u8981\u4fdd\u7559\u5c0f\u6570 cout<<func(arr_1, arr_2, len_1, len_2)<<endl; } }","title":"1041 \u5bfb\u627e\u4e24\u4e2a\u6b63\u5e8f\u6570\u7ec4\u7684\u4e2d\u4f4d\u6570"},{"location":"1042%20%E6%9C%80%E4%BD%8E%E7%A5%A8%E4%BB%B7/","text":"#include<iostream> #include<algorithm> #include<iomanip> #include<climits> using namespace std; // leetcode 983 Minimum Cost For Tickets. // https://leetcode.com/problems/minimum-cost-for-tickets/ int func(int days[], int costs[], int len, int n_costs) { // dp[i]\u8868\u793a\u524di\u5929\u65c5\u884c\u7684\u8d39\u7528 int dp[366]; for(int i=0;i<366;i++) { dp[i] = INT_MAX; } // \u524d0\u5929\uff0c\u6ca1\u6709\u65c5\u884c\uff0c\u6ca1\u6709\u8d39\u7528 dp[0] = 0; // \u626b\u63cfdays\u6570\u7ec4\u7684\u4e0b\u6807 int idx = 0; for(int i=1;i<366;i++) { // \u7b2ci\u5929\u4e0d\u65c5\u884c\uff0c\u9632\u6b62idx\u4e0b\u6807\u51fa\u754c // idx>=len\u5fc5\u987b\u653e\u5728\u524d\u9762\uff0c\u5148\u8fdb\u884c\u5224\u65ad\uff0c\u5426\u5219\u4f1a\u9020\u6210\u7f13\u51b2\u533a\u6ea2\u51fa if(days[idx] != i || idx>=len) { // \u8d39\u7528\u548c\u4e4b\u524d\u4fdd\u6301\u4e0d\u53d8 dp[i] = dp[i-1]; } // \u7b2ci\u5929\u65c5\u884c else { // \u4e09\u79cd\u8d39\u7528\u4f9d\u6b21\u6bd4\u8f83\uff0c\u6ce8\u610f\u9632\u6b62i-1\uff0ci-7\uff0ci-30\u51fa\u4e86\u8fb9\u754c dp[i] = min(dp[i], ( i>=1 ? dp[i-1] : 0 ) + costs[0]); // \u4e00\u5929\u7684\u8d39\u7528 dp[i] = min(dp[i], ( i>=7 ? dp[i-7] : 0) + costs[1]); // \u4e03\u5929\u7684\u8d39\u7528 dp[i] = min(dp[i], ( i>=30 ? dp[i-30] : 0) + costs[2]); // \u4e00\u4e2a\u6708\u7684\u8d39\u7528 // \u4e0b\u4e00\u6b21\u65c5\u884c\u7684\u65e5\u671f idx++; } } return dp[365]; } int main() { const int n_costs = 3; int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { int len; cin>>len; int days[len]; int costs[n_costs]; for(int j=0;j<len;j++) { cin>>days[j]; } for(int j=0;j<n_costs;j++) { cin>>costs[j]; } cout<<func(days, costs, len, n_costs)<<endl; } }","title":"1042 \u6700\u4f4e\u7968\u4ef7"},{"location":"1043%20%E9%B8%A1%E8%9B%8B%E6%8E%89%E8%90%BD/","text":"#include<iostream> #include<vector> #include<iomanip> using namespace std; int func(int n_egg, int n_floor) { vector<vector<int>> dp(n_floor+1, vector<int>(n_egg+1, 0)); int m = 0; while (dp[m][n_egg] < n_floor) { m++; for (int k = 1; k <= n_egg; ++k) dp[m][k] = dp[m - 1][k - 1] + dp[m - 1][k] + 1; } return m; } int main() { int n_test; cin>>n_test; for(int i=0;i<n_test;i++) { int n_egg; int n_floor; cin>>n_egg; cin>>n_floor; cout<<func(n_egg, n_floor)<<endl; } }","title":"1043 \u9e21\u86cb\u6389\u843d"}]}